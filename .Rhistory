curve(f.t, from = 0, to = 5)
curve(S.t, from = 0, to = 5)
lambda.t <- function(t){
return(ifelse(t <= tau, lambda1, lambda2))
}
f.t <- function(t){
return(ifelse(t <= tau, lambda1*exp(-lambda1*t), lambda2*exp(-lambda2*t + (lambda2 - lambda1)*tau)))
}
S.t <- function(t){
return(ifelse(t <= tau, exp(-lambda1*t), exp(-lambda2*t + (lambda2 - lambda1)*tau)))
}
lambda1 = 1
lambda2 = 0.5
tau = 5
curve(lambda.t, from = 0, to = 10)
curve(f.t, from = 0, to = 5)
curve(S.t, from = 0, to = 5)
lambda1 = 1
lambda2 = 10
tau = 5
curve(lambda.t, from = 0, to = 10)
curve(f.t, from = 0, to = 5)
curve(S.t, from = 0, to = 5)
lambda.t <- function(t){
return(ifelse(t <= tau, lambda1, lambda2))
}
f.t <- function(t){
print(tau)
return(ifelse(t <= tau, lambda1*exp(-lambda1*t), lambda2*exp(-lambda2*t + (lambda2 - lambda1)*tau)))
}
S.t <- function(t){
return(ifelse(t <= tau, exp(-lambda1*t), exp(-lambda2*t + (lambda2 - lambda1)*tau)))
}
lambda1 = 1
lambda2 = 10
tau = 5
curve(lambda.t, from = 0, to = 10)
curve(f.t, from = 0, to = 5)
curve(S.t, from = 0, to = 5)
lambda1 = 0.1
lambda2 = 10
tau = 5
curve(lambda.t, from = 0, to = 10)
curve(f.t, from = 0, to = 10)
curve(S.t, from = 0, to = 10)
lambda1 = 0.1
lambda2 = 10
tau = 5
curve(lambda.t, from = 0, to = 2*tau)
curve(f.t, from = 0, to = 2*tau)
curve(S.t, from = 0, to = 2*tau)
lambda1 = 0.1
lambda2 = 0.2
tau = 5
curve(lambda.t, from = 0, to = 2*tau)
curve(f.t, from = 0, to = 2*tau)
curve(S.t, from = 0, to = 2*tau)
lambda1 = 0.2
lambda2 = 0.1
tau = 5
curve(lambda.t, from = 0, to = 2*tau)
curve(f.t, from = 0, to = 2*tau)
curve(S.t, from = 0, to = 2*tau)
lambda.t <- function(t){
return(ifelse(t <= tau, lambda1, lambda2))
}
f.t <- function(t){
return(ifelse(t <= tau, lambda1*exp(-lambda1*t), lambda2*exp(-lambda2*t + (lambda2 - lambda1)*tau)))
}
S.t <- function(t){
return(ifelse(t <= tau, exp(-lambda1*t), exp(-lambda2*t + (lambda2 - lambda1)*tau)))
}
lambda1 = 0.2
lambda2 = 0.1
tau = 5
curve(lambda.t, from = 0, to = 2*tau)
curve(f.t, from = 0, to = 2*tau)
curve(S.t, from = 0, to = 2*tau)
confint(fitEx)
rm(list=ls())
library(knitr)
opts_chunk$set(warning=FALSE, message=FALSE, echo = FALSE)
source("C:/Users/songdongyuan/Documents/R/BST233/Utilities_Part5_2018.R")
confint(fitEx)
library(survival)
fitEx <- survreg(Surv(obstime, death) ~ gender + race, dist="exponential", data = kidney)
kidney <- read.csv("D:/MS/Master Course/BST233/Week14/Kidney_data.dat.csv", header = T)
kidney$gender <- as.factor(ifelse(kidney$gender == 1, "male", "female"))
kidney$race <- as.factor(ifelse(kidney$race == 1, "white", "black"))
library(survival)
fitEx <- survreg(Surv(obstime, death) ~ gender + race, dist="exponential", data = kidney)
summary(fitEx)
confint(fitEx)
getCI(fitEx)
exp(confint(fitEx))
cbind(coef(fitEx), confint(fitEx))
cbind(coef(fitEx), confint(fitEx))
vcov(fitEx)
cbind(coef(fitEx), confint(fitEx))
vcov(fitEx)
new.data <- cbind(as.factor(c("male", "male", "female", "female")),
as.factor("white", "white", "black", "black"))
cbind(coef(fitEx), confint(fitEx))
vcov(fitEx)
new.data <- cbind(as.factor(c("male", "male", "female", "female")),
as.factor(c("white", "white", "black", "black")))
cbind(coef(fitEx), confint(fitEx))
vcov(fitEx)
new.data <- cbind(as.factor(c("male", "male", "female", "female")),
as.factor(c("white", "white", "black", "black")))
predict(fitEx)
new.data
cbind(coef(fitEx), confint(fitEx))
vcov(fitEx)
gender <- c("male", "male", "female", "female")
race <- c("white", "white", "black", "black")
new.data <- cbind(gender, race)
new.data
str(new.data)
cbind(coef(fitEx), confint(fitEx))
vcov(fitEx)
gender <- c("male", "male", "female", "female")
race <- c("white", "white", "black", "black")
new.data <- data.frame(cbind(gender, race), stringsAsFactors = T)
predict(fitEx, newdata = new.data)
cbind(coef(fitEx), confint(fitEx))
vcov(fitEx)
gender <- c("male", "male", "female", "female")
race <- c("white", "white", "black", "black")
new.data <- data.frame(cbind(gender, race), stringsAsFactors = T)
predict(fitEx, newdata = new.data, interval = prediction)
cbind(coef(fitEx), confint(fitEx))
vcov(fitEx)
gender <- c("male", "male", "female", "female")
race <- c("white", "white", "black", "black")
new.data <- data.frame(cbind(gender, race), stringsAsFactors = T)
predict(fitEx, newdata = new.data, interval = "prediction")
str(kidney)
kidney <- read.csv("D:/MS/Master Course/BST233/Week14/Kidney_data.dat.csv", header = T)
kidney$death <- as.factor(kidney$death)
kidney$gender <- as.factor(ifelse(kidney$gender == 1, "male", "female"))
kidney$race <- as.factor(ifelse(kidney$race == 1, "white", "black"))
library(survival)
fitEx <- survreg(Surv(obstime, death) ~ gender + race, dist="exponential", data = kidney)
str(kidney)
kidney <- read.csv("D:/MS/Master Course/BST233/Week14/Kidney_data.dat.csv", header = T)
kidney$death <- as.factor(kidney$death) - 1
kidney$gender <- as.factor(ifelse(kidney$gender == 1, "male", "female"))
kidney$race <- as.factor(ifelse(kidney$race == 1, "white", "black"))
kidney <- read.csv("D:/MS/Master Course/BST233/Week14/Kidney_data.dat.csv", header = T)
kidney$gender <- as.factor(ifelse(kidney$gender == 1, "male", "female"))
kidney$race <- as.factor(ifelse(kidney$race == 1, "white", "black"))
library(survival)
fitEx <- survreg(Surv(obstime, death) ~ gender + race, dist="exponential", data = kidney)
summary(fitEx)
cbind(coef(fitEx), confint(fitEx))
vcov(fitEx)
gender <- c("male", "male", "female", "female")
race <- c("white", "white", "black", "black")
new.data <- data.frame(cbind(gender, race), stringsAsFactors = T)
predict(fitEx, newdata = new.data, interval = "prediction")
kidney <- read.csv("D:/MS/Master Course/BST233/Week14/Kidney_data.dat.csv", header = T)
kidney$death <- factor(kidney$death, levels = c(0, 1))
kidney$gender <- as.factor(ifelse(kidney$gender == 1, "male", "female"))
kidney$race <- as.factor(ifelse(kidney$race == 1, "white", "black"))
library(survival)
fitEx <- survreg(Surv(obstime, death) ~ gender + race, dist="exponential", data = kidney)
str(kidney)
library(survival)
fitEx <- survreg(Surv(obstime, event = death) ~ gender + race, dist="exponential", data = kidney)
kidney <- read.csv("D:/MS/Master Course/BST233/Week14/Kidney_data.dat.csv", header = T)
kidney$gender <- as.factor(ifelse(kidney$gender == 1, "male", "female"))
kidney$race <- as.factor(ifelse(kidney$race == 1, "white", "black"))
kidney <- read.csv("D:/MS/Master Course/BST233/Week14/Kidney_data.dat.csv", header = T)
kidney$gender <- as.factor(ifelse(kidney$gender == 1, "male", "female"))
kidney$race <- as.factor(ifelse(kidney$race == 1, "white", "black"))
library(survival)
fitEx <- survreg(Surv(obstime, event = death) ~ gender + race, dist="exponential", data = kidney)
summary(fitEx)
library(survival)
fitEx <- survreg(Surv(time = obstime, event = death) ~ gender + race, dist="exponential", data = kidney)
summary(fitEx)
cbind(coef(fitEx), confint(fitEx))
vcov(fitEx)
gender <- c("male", "male", "female", "female")
race <- c("white", "white", "black", "black")
new.data <- data.frame(cbind(gender, race), stringsAsFactors = T)
predict(fitEx, newdata = new.data, interval = "prediction")
library(survival)
fitEx <- survreg(Surv(time = obstime, event = death) ~ gender + race, dist="exponential", data = kidney)
summary(fitEx)
exp(coef(fitEx))
library(survival)
fitEx <- survreg(Surv(time = obstime/2, event = death) ~ gender + race, dist="exponential", data = kidney)
summary(fitEx)
exp(coef(fitEx))
library(survival)
fitEx <- survreg(Surv(time = obstime/10, event = death) ~ gender + race, dist="exponential", data = kidney)
summary(fitEx)
exp(coef(fitEx))
library(survival)
fitEx <- survreg(Surv(time = log(obstime), event = death) ~ gender + race, dist="exponential", data = kidney)
kidney$obstime
library(survival)
fitEx <- survreg(Surv(time = kidney$obstime, event = death) ~ gender + race, dist="exponential", data = kidney)
summary(fitEx)
exp(coef(fitEx))
library(survival)
fitEx <- survreg(Surv(time = obstime, event = death) ~ gender + race, dist="exponential", data = kidney)
summary(fitEx)
exp(coef(fitEx))
cbind(coef(fitEx), confint(fitEx))
vcov(fitEx)
gender <- c("male", "male", "female", "female")
race <- c("white", "white", "black", "black")
new.data <- data.frame(cbind(gender, race), stringsAsFactors = T)
predict(fitEx, newdata = new.data, interval = "prediction", type = "quantile")
cbind(coef(fitEx), confint(fitEx))
vcov(fitEx)
gender <- c("male", "male", "female", "female")
race <- c("white", "white", "black", "black")
new.data <- data.frame(cbind(gender, race), stringsAsFactors = T)
predict(fitEx, newdata = new.data, interval = "prediction", type = "linear")
q
setwd("C:/Users/songdongyuan/group02_final_project_packet")
source("https://bioconductor.org/biocLite.R")
setwd("C:/Users/songdongyuan/group02_final_project_packet")
source("https://bioconductor.org/biocLite.R")
library(edgeR)
library(limma)
library(Glimma)
library(gplots)
library(org.Mm.eg.db)
library(RColorBrewer)
library(DESeq2)
install.packages("data.table", dependencies = FALSE)
library(DESeq2)
library(DEFormats)
filtered <- read.csv("filtered.tsv", sep = "\t", row.names = 1, header= TRUE, stringsAsFactors = F)
filtered <- filtered[, c(4,2,6, 3,1,5)]
group <- c("Co", "Co", "Co", "Mono", "Mono", "Mono")
names(filtered) <- c("MM_HS5", "RPMI_HS5", "KMS11_HS5", "MM", "RPMI", "KMS11")
filtered_counts <- DGEList(filtered, group = group)
filtered_counts$samples$lib.size
barplot(filtered_counts$samples$lib.size,names=colnames(filtered_counts),las=2)
# Add a title to the plot
title("Barplot of library sizes")
# Get log2 counts per million
logcounts <- cpm(filtered_counts,log=TRUE)
# Check distributions of samples using boxplots
boxplot(logcounts, xlab="", ylab="Log2 counts per million",las=2)
# MA plot
par(mfrow = c(2,3))
title("Boxplots of logCPMs (unnormalised)")
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(logcounts),col="blue")
maPlot(filtered_counts$counts[,1], filtered_counts$counts[,2], lowess = T)
title("MA plot (unnormalised) of #1 & #2")
maPlot(filtered_counts$counts[,1], filtered_counts$counts[,3], lowess = T)
maPlot(filtered_counts$counts[,2], filtered_counts$counts[,3], lowess = T)
title("MA plot (unnormalised) of #1 & #3")
title("MA plot (unnormalised) of #2 & #3")
maPlot(filtered_counts$counts[,4], filtered_counts$counts[,5], lowess = T)
title("MA plot (unnormalised) of #4 & #5")
maPlot(filtered_counts$counts[,4], filtered_counts$counts[,6], lowess = T)
title("MA plot (unnormalised) of #4 & #6")
maPlot(filtered_counts$counts[,5], filtered_counts$counts[,6], lowess = T)
title("MA plot (unnormalised) of #5 & #6")
# Apply normalisation to DGEList object
filtered_counts_n <- calcNormFactors(filtered_counts, method = "TMM")
par(mfrow = c(2,3))
maPlot(filtered_counts_n$counts[,1], filtered_counts_n$counts[,2], lowess = T)
title("MA plot (normalised with TMM) of #1 & #2")
maPlot(filtered_counts_n$counts[,1], filtered_counts_n$counts[,3], lowess = T)
title("MA plot (normalised with TMM) of #1 & #3")
maPlot(filtered_counts_n$counts[,2], filtered_counts_n$counts[,3], lowess = T)
title("MA plot (normalised with TMM) of #2 & #3")
maPlot(filtered_counts_n$counts[,4], filtered_counts_n$counts[,5], lowess = T)
title("MA plot (normalised with TMM) of #4 & #5")
maPlot(filtered_counts_n$counts[,4], filtered_counts_n$counts[,6], lowess = T)
title("MA plot (normalised with TMM) of #4 & #6")
maPlot(filtered_counts_n$counts[,5], filtered_counts_n$counts[,6], lowess = T)
title("MA plot (normalised with TMM) of #5 & #6")
par(mfrow = c(1, 2))
# Get log2 counts per million
logcounts <- cpm(filtered_counts,log=TRUE)
# Check distributions of samples using boxplots
boxplot(logcounts, xlab="", ylab="Log2 counts per million",las=2)
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
# Get log2 counts per million
logcounts <- cpm(filtered_counts_n,log=TRUE)
# Check distributions of samples using boxplots
boxplot(logcounts, xlab="", ylab="Log2 counts per million",las=2)
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (TMM normalised)")
# Create design matrix
design <- model.matrix(~ 0 + group)
# Fit limma
logCPM <- cpm(filtered_counts_n, log=TRUE, prior.count=1)
fit <- lmFit(logCPM, design)
fit <- eBayes(fit, trend=TRUE)
filtered_counts_n$counts <- round(filtered_counts_n$counts)
# You can easily convert data format between edgeR and DESeq2
dds <- as.DESeqDataSet(filtered_counts_n)
res <- DESeq(dds)
res <- results(res)
summary(res)
resSig <- res[ which(res$padj < 0.1 ), ]
DEgene_list <- rownames(resSig)
write.table(DEgene_list, file = "DEgene_list.tsv", row.names = FALSE, sep = '\t', col.names = F)
install.packages("data.table")
#http://nbcgib.uesc.br/mirrors/cran/
install.packages('data.table', repo='http://nbcgib.uesc.br/mirrors/cran/')
#R3.3.5 has issues when installing data.table
install.packages("https://socialsciences.mcmaster.ca/jfox/.Pickup/data.table_1.10.4-3.zip";,
repos=NULL, type="win.binary")
#R3.3.5 has issues when installing data.table
install.packages("https://socialsciences.mcmaster.ca/jfox/.Pickup/data.table_1.10.4-3.zip",
repos=NULL, type="win.binary")
library(edgeR)
library(limma)
library(Glimma)
library(gplots)
library(org.Mm.eg.db)
library(RColorBrewer)
library(DESeq2)
library(DEFormats)
filtered <- read.csv("filtered.tsv", sep = "\t", row.names = 1, header= TRUE, stringsAsFactors = F)
filtered <- filtered[, c(4,2,6, 3,1,5)]
group <- c("Co", "Co", "Co", "Mono", "Mono", "Mono")
names(filtered) <- c("MM_HS5", "RPMI_HS5", "KMS11_HS5", "MM", "RPMI", "KMS11")
filtered_counts <- DGEList(filtered, group = group)
filtered_counts$samples$lib.size
barplot(filtered_counts$samples$lib.size,names=colnames(filtered_counts),las=2)
# Add a title to the plot
title("Barplot of library sizes")
# Get log2 counts per million
logcounts <- cpm(filtered_counts,log=TRUE)
# Check distributions of samples using boxplots
boxplot(logcounts, xlab="", ylab="Log2 counts per million",las=2)
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
# MA plot
par(mfrow = c(2,3))
maPlot(filtered_counts$counts[,1], filtered_counts$counts[,2], lowess = T)
title("MA plot (unnormalised) of #1 & #2")
maPlot(filtered_counts$counts[,1], filtered_counts$counts[,3], lowess = T)
title("MA plot (unnormalised) of #1 & #3")
maPlot(filtered_counts$counts[,2], filtered_counts$counts[,3], lowess = T)
title("MA plot (unnormalised) of #2 & #3")
maPlot(filtered_counts$counts[,4], filtered_counts$counts[,5], lowess = T)
title("MA plot (unnormalised) of #4 & #5")
maPlot(filtered_counts$counts[,4], filtered_counts$counts[,6], lowess = T)
title("MA plot (unnormalised) of #4 & #6")
maPlot(filtered_counts$counts[,5], filtered_counts$counts[,6], lowess = T)
title("MA plot (unnormalised) of #5 & #6")
# Apply normalisation to DGEList object
filtered_counts_n <- calcNormFactors(filtered_counts, method = "TMM")
par(mfrow = c(2,3))
maPlot(filtered_counts_n$counts[,1], filtered_counts_n$counts[,2], lowess = T)
title("MA plot (normalised with TMM) of #1 & #2")
maPlot(filtered_counts_n$counts[,1], filtered_counts_n$counts[,3], lowess = T)
title("MA plot (normalised with TMM) of #1 & #3")
maPlot(filtered_counts_n$counts[,2], filtered_counts_n$counts[,3], lowess = T)
title("MA plot (normalised with TMM) of #2 & #3")
maPlot(filtered_counts_n$counts[,4], filtered_counts_n$counts[,5], lowess = T)
title("MA plot (normalised with TMM) of #4 & #5")
maPlot(filtered_counts_n$counts[,4], filtered_counts_n$counts[,6], lowess = T)
title("MA plot (normalised with TMM) of #4 & #6")
maPlot(filtered_counts_n$counts[,5], filtered_counts_n$counts[,6], lowess = T)
title("MA plot (normalised with TMM) of #5 & #6")
par(mfrow = c(1, 2))
# Get log2 counts per million
logcounts <- cpm(filtered_counts,log=TRUE)
# Check distributions of samples using boxplots
boxplot(logcounts, xlab="", ylab="Log2 counts per million",las=2)
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
# Get log2 counts per million
logcounts <- cpm(filtered_counts_n,log=TRUE)
# Check distributions of samples using boxplots
boxplot(logcounts, xlab="", ylab="Log2 counts per million",las=2)
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (TMM normalised)")
# Using limma
# Create design matrix
design <- model.matrix(~ 0 + group)
# Fit limma
logCPM <- cpm(filtered_counts_n, log=TRUE, prior.count=1)
fit <- lmFit(logCPM, design)
fit <- eBayes(fit, trend=TRUE)
# Using DESeq2
filtered_counts_n$counts <- round(filtered_counts_n$counts)
# You can easily convert data format between edgeR and DESeq2
dds <- as.DESeqDataSet(filtered_counts_n)
res <- DESeq(dds)
res <- results(res)
summary(res)
resSig <- res[ which(res$padj < 0.1 ), ]
DEgene_list <- rownames(resSig)
write.table(DEgene_list, file = "DEgene_list.tsv", row.names = FALSE, sep = '\t', col.names = F)
library(edgeR)
library(limma)
library(Glimma)
library(gplots)
library(org.Mm.eg.db)
library(RColorBrewer)
library(DESeq2)
library(DEFormats)
setwd("C:/Users/songdongyuan/group02_final_project_packet")
source("https://bioconductor.org/biocLite.R")
#R3.3.5 has issues when installing data.table
#install.packages("https://socialsciences.mcmaster.ca/jfox/.Pickup/data.table_1.10.4-3.zip",
repos=NULL, type="win.binary")
#biocLite("edgeR")
#biocLite("limma")
#biocLite("Glimma")
#biocLite("org.Mm.eg.db")
#biocLite("RColorBrewer")
#biocLite("DESeq2")
#biocLite("DEFormats")
library(edgeR)
library(limma)
library(Glimma)
library(gplots)
library(org.Mm.eg.db)
library(RColorBrewer)
library(DESeq2)
library(DEFormats)
filtered <- read.csv("filtered.tsv", sep = "\t", row.names = 1, header= TRUE, stringsAsFactors = F)
filtered <- filtered[, c(4,2,6, 3,1,5)]
group <- c("Co", "Co", "Co", "Mono", "Mono", "Mono")
names(filtered) <- c("MM_HS5", "RPMI_HS5", "KMS11_HS5", "MM", "RPMI", "KMS11")
filtered_counts <- DGEList(filtered, group = group)
filtered_counts$samples$lib.size
barplot(filtered_counts$samples$lib.size,names=colnames(filtered_counts),las=2)
# Add a title to the plot
title("Barplot of library sizes")
# Get log2 counts per million
logcounts <- cpm(filtered_counts,log=TRUE)
# Check distributions of samples using boxplots
boxplot(logcounts, xlab="", ylab="Log2 counts per million",las=2)
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
# MA plot
par(mfrow = c(2,3))
maPlot(filtered_counts$counts[,1], filtered_counts$counts[,2], lowess = T)
title("MA plot (unnormalised) of #1 & #2")
maPlot(filtered_counts$counts[,1], filtered_counts$counts[,3], lowess = T)
title("MA plot (unnormalised) of #1 & #3")
maPlot(filtered_counts$counts[,2], filtered_counts$counts[,3], lowess = T)
title("MA plot (unnormalised) of #2 & #3")
maPlot(filtered_counts$counts[,4], filtered_counts$counts[,5], lowess = T)
title("MA plot (unnormalised) of #4 & #5")
maPlot(filtered_counts$counts[,4], filtered_counts$counts[,6], lowess = T)
title("MA plot (unnormalised) of #4 & #6")
maPlot(filtered_counts$counts[,5], filtered_counts$counts[,6], lowess = T)
title("MA plot (unnormalised) of #5 & #6")
# Apply normalisation to DGEList object
filtered_counts_n <- calcNormFactors(filtered_counts, method = "TMM")
par(mfrow = c(2,3))
maPlot(filtered_counts_n$counts[,1], filtered_counts_n$counts[,2], lowess = T)
title("MA plot (normalised with TMM) of #1 & #2")
maPlot(filtered_counts_n$counts[,1], filtered_counts_n$counts[,3], lowess = T)
title("MA plot (normalised with TMM) of #1 & #3")
maPlot(filtered_counts_n$counts[,2], filtered_counts_n$counts[,3], lowess = T)
title("MA plot (normalised with TMM) of #2 & #3")
maPlot(filtered_counts_n$counts[,4], filtered_counts_n$counts[,5], lowess = T)
title("MA plot (normalised with TMM) of #4 & #5")
maPlot(filtered_counts_n$counts[,4], filtered_counts_n$counts[,6], lowess = T)
title("MA plot (normalised with TMM) of #4 & #6")
maPlot(filtered_counts_n$counts[,5], filtered_counts_n$counts[,6], lowess = T)
title("MA plot (normalised with TMM) of #5 & #6")
par(mfrow = c(1, 2))
# Get log2 counts per million
logcounts <- cpm(filtered_counts,log=TRUE)
# Check distributions of samples using boxplots
boxplot(logcounts, xlab="", ylab="Log2 counts per million",las=2)
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
# Get log2 counts per million
logcounts <- cpm(filtered_counts_n,log=TRUE)
# Check distributions of samples using boxplots
boxplot(logcounts, xlab="", ylab="Log2 counts per million",las=2)
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (TMM normalised)")
# Using limma
# Create design matrix
design <- model.matrix(~ 0 + group)
# Fit limma
logCPM <- cpm(filtered_counts_n, log=TRUE, prior.count=1)
fit <- lmFit(logCPM, design)
fit <- eBayes(fit, trend=TRUE)
# Using DESeq2
filtered_counts_n$counts <- round(filtered_counts_n$counts)
# You can easily convert data format between edgeR and DESeq2
dds <- as.DESeqDataSet(filtered_counts_n)
res <- DESeq(dds)
res <- results(res)
summary(res)
resSig <- res[ which(res$padj < 0.1 ), ]
DEgene_list <- rownames(resSig)
write.table(DEgene_list, file = "DEgene_list.tsv", row.names = FALSE, sep = '\t', col.names = F)
